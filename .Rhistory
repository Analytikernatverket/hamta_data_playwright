# {if (berakna_index) geom_hline(yintercept = 100, color = "grey32", linewidth = 1.2)} +
# geom_line(aes(color = chart_col), linewidth = 1.5)
} else {
p<-plot_df %>% ggplot(aes(x=!!x_var, y=total, group = !!x_grupp, linetype = !!x_grupp)) +
{if (berakna_index) geom_hline(yintercept = 100, color = "grey32", linewidth = 1.2)} +
geom_line(aes(color = !!x_grupp), linewidth = 1.5)
if (!diagram_facet | facet_legend_bottom) legend_pos <- "bottom"
}
if(legend_tabort) legend_pos <- "none"
# fortsätt att fylla på objektet p som är diagrammet
if(lagga_till_punkter){
p <- p + geom_point(aes(color = !!x_grupp), size = 2.5)
}
p <- p +
theme(axis.text.x = element_text(size = x_axis_storlek, angle = x_axis_lutning, hjust = 1),
axis.text.y = element_text(size = y_axis_storlek),
axis.ticks = element_blank(),
legend.position = legend_pos,
legend.key = element_rect(fill = "white"),
legend.margin = margin(0,0,0,0),
legend.title = element_blank(),
legend.text = element_text(size = legend_storlek),
plot.title = element_textbox_simple(
size = diagram_titel_storlek,
width = unit(0.9, "npc"),  # Bredd som proportion av plottens område
halign = 0.5,  # Centrera texten
margin = margin(7, 0, 7, 0)),
plot.title.position = "plot",
#plot.title = element_text(hjust = 0.5, size = 20),
plot.subtitle = element_text(hjust = undertitel_hjust, size = undertitel_storlek),
plot.caption = element_text(face = "italic",
hjust = 0, vjust = 0, size = diagram_caption_storlek),
plot.caption.position = "plot",
panel.spacing.x = unit(facet_space_diag_horisont, "mm"),
panel.background = element_rect(fill = "white"),
panel.grid.major.y = element_line(linewidth=0.8, colour = "lightgrey"),
panel.grid.minor.y = element_line(linewidth=0.4, colour = "lightgrey") ,
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank()) +
{if (utan_diagramtitel) theme(plot.title = element_blank())} +
labs(title = diagram_titel,
subtitle = diagram_undertitel,
x = manual_x_axis_title,
caption = diagram_capt,
y = y_titel,
color = legend_titel,
linetype = NULL) +
guides(color = guide_legend(title.position = "top",
title.hjust = 0.5,
reverse = legend_vand_ordning,
ncol = legend_kolumner,
nrow = legend_rader,
byrow = legend_byrow)) +
scale_color_manual(values = chart_col) +
{ if (AF_special) {
scale_x_continuous(expand = c(0,.3), breaks = seq(1,53, by = 1))
}} +
{ if (!is.na(x_axis_visa_var_xe_etikett)) {
scale_x_discrete(expand = c(0,0), breaks = every_nth(n = x_axis_visa_var_xe_etikett, sista_vardet = inkludera_sista_vardet_var_xe_etikett, ta_bort_nast_sista = x_axis_var_xe_etikett_ta_bort_nast_sista_vardet))
}} +
# om det finns en linjetyp_vektor
#{ if (!all(is.na(linjetyp_typvektor)) & (linjetyp_kolumn != skickad_x_grupp)) {
{ if (!all(is.na(linjetyp_typvektor))) {
scale_linetype_manual(values = linjetyp_typvektor)
}} +
# scale_y_continuous(breaks = seq(min_yvar, max_yvar,
#                                 by = round(max_yvar / 6, (nchar(trunc(max_yvar/6))-1)*-1)),
#                    minor_breaks = seq(min_yvar, max_yvar, by = min_by_yvar),
# Ändrat nedan så att man kan bestämma värdet på marginalen för y-axeln
{if (!diagram_facet | (facet_scale == "fixed" & diagram_facet)){
scale_y_continuous(breaks = seq(min_yvar, max_yvar,
by = maj_by_yvar),
minor_breaks = seq(min_yvar, max_yvar, by = min_by_yvar),
labels = etikett_format,
limits = c(min_yvar, max_yvar),
expand = marginal_y_axis)
} else {                        # om det fuckar med facet-diagram, ta bort denna else-sats då. Den gör att procentformatet funkar även på free-scale facetdiagram men jag är inte säker att det funkar för övriga diagram
scale_y_continuous(labels = etikett_format,
expand = marginal_y_axis)
}} +
# scale_y_continuous(breaks = seq(min_yvar, max_yvar,
#                                 by = maj_by_yvar),
#                    minor_breaks = seq(min_yvar, max_yvar, by = min_by_yvar),
#                    labels = etikett_format,
#                    #expand = expand_vekt,
#                    limits = c(limit_min,max_yvar),
#                    expand = c(0,0)) +
#
#labels = function(x) format(x, big.mark = " ")) +
#{if (diagram_facet & x_grupp != "NA") facet_wrap(as.formula(paste("~",facet_grp)), scales = facet_scale) } +
#{if (diagram_facet) facet_wrap(as.formula(paste("~",facet_grp)), scales = facet_scale) } +
{if (diagram_facet) facet_wrap(as.formula(paste("~",facet_grp)), scales = "free",
ncol = facet_kolumner,
nrow = facet_rader) } +
#{if (diagram_facet & x_grupp != "NA"){               # gammal, om det krånglar kan man lägga till x_grupp-delen igen
{if (diagram_facet & facet_sort) scale_x_reordered()} +                 # sorterar varje facetgrupp för sig om man kör facet_sort
{if (diagram_facet){
theme(strip.text = element_text(color = "black", size = facet_rubrik_storlek),
strip.background = element_blank(),
axis.text.x = element_text(size = facet_x_axis_storlek),
axis.text.y = element_text(size = facet_y_axis_storlek)
)
} else {
theme(strip.text = element_blank())
}}
# skriv till diagramfil om sådan är vald
if (skriv_till_diagramfil){
# Ändra höjd och bredd på den sparade png-filen, + ange mapp och filnamn
bredd <- diagramfil_bredd
hojd <- diagramfil_hojd
if (diagram_bildformat != "png") filnamn_diagram <- filnamn_diagram %>% str_replace(".png", paste0(".", diagram_bildformat))
fullpath <- paste0(output_mapp, filnamn_diagram)
ggsave(fullpath, width = bredd, height = hojd)
# Lägg till logga till diagrammet =======================================
if (lagg_pa_logga) {
if (is.na(logga_path)) logga_path <- hamta_logga_path()       # hämta logga_path i funktion först i denna fil
if (!is.null(logga_path)){
add_logo(
plot_path = paste0(output_mapp, filnamn_diagram), # url or local file for the plot
logo_path = logga_path, # url or local file for the logo
logo_position = "bottom right", # choose a corner
# 'top left', 'top right', 'bottom left' or 'bottom right'
logo_scale = logga_scaling,
#10 as default, but can change to manually make logo bigger (lägre tal = större logga)
replace = TRUE
)
} # if !is.null(logga_path)
} # if lagg_pa_logga
} # if skriv_till_diagramfil
return(p)
} # slut funktion för att skriva linjediagram
skapa_koropletkarta_ggplot <- function(
sf_objekt,                        # sf-objekt (polygondata) som ska plottas
vardekolumn,                      # Kolumnnamn i sf_objekt som innehåller värdet att färgsätta efter
klassindelning = NULL,            # "kvantil", "pretty", "natural" alternativt en vektor men gränser för klassindelningen
klasser_antal = 5,                # Antal klasser om klassindelning är automatisk
klasser_kontinuerlig_skala_oavsett = FALSE,    # väljer kontinuerlig skala oavsett hur värdena ser ut i datasetet
legend_titel  = NULL,            # Titel i legenden, NULL om inte vill ha någon
legend_titel_storlek = 12,       # Storlek på texten i legendtiteln
legend_text_storlek = 9,         # Storlek på texten i legenden
legend_objekt_storlek = 1.2,       # Storlek på själva objekten i legenden (oftast kvadrater), standardvärde är 1
legend_position = "right",       # "dala", "right", "left", "top", "bottom" eller "none", "bottom-right", "top-left" etc. alternativt c(0,0) för nedre vänstra hörnet, c(1,0) för nedre högre hörnet, c(1,1) för övre högra hörnet och c(0,1) för övre vänstra hörnet, c(0.5, 0.5) i mitten
legend_justification = "center", # samma som ovan men gällande vilken del av legenden som avses med legend_position
karta_titel = NULL,              # Huvudtitel på kartan
karta_titel_storlek = 20,        # storlek på huvudtitel i kartan
karta_caption = NULL,            # caption för källa etc.
karta_caption_storlek = 9,       # textstorlek på caption
karta_fargvektor = NULL,         # färgvektor om man vill skicka med någon
karta_farg_hogst = "mork",       # "mork" = mörk färg för höga värden, "ljus" = ljus färg för höga värden, NA = färgskalan ändras inte
na_farg = "grey90",              # färg för na-värden, "transparent" för genomskinliga polygoner
karta_bakgrund = "white",        # "transparent" eller annan färg
karta_hojd = 7,                  # höjden på kartan
karta_bredd = "auto",            # kan vara en siffra, eller "auto" för att anpassa plotten till formen på gis-lagret som skickas in
karta_upplosning = 300,          # upplösning i dpi för ggsave()
filnamn = NULL,                  # filnamn och output_mapp om man vill spara kartan som en bildfil (.png)
output_mapp = NULL,              # filnamn och output_mapp om man vill spara kartan som en bildfil (.png)
logga_url = NULL,                # sökväg till logga, om man vill ha en logga med
logga_storlek = 0.06,                        # procent av kartans bredd
logga_position = "bottom-right",             # Logga kan läggas i ett av fyra hörn: bottom-right, bottom-left, top-right, top-left
etiketter_kolumn = NULL,                     # kolumn som innehåller etiketter för polygonerna
etiketter_storlek = 2,                       # storlek på etiketter för polygonerna
etiketter_farg = "black",                    # färg på dataetiketterna för polygoner
etiketter_buffer_farg = NA,                  # en kant runt etiketterna för att de ska synas bättre
returnera_ggobj = TRUE,                      # om funktionen ska returnera ett ggplot-objekt med kartan
granser_farg = "darkgrey",                   # gränser mellan polygonerna
granser_tjocklek = 0.4                       # tjocklek på gränser mellan polygonerna
) {
# --- Säkerställ att geometrikolumnen heter "geometry" och inte krockar med andra kolumner ---
# Hämta sf-geometrikolumnens riktiga namn
geom_kol <- attr(sf_objekt, "sf_column")
# Om det redan finns en BORTA kolumn som heter "geometry" men som inte är geometri → döp om den
if ("geometry" %in% names(sf_objekt) && geom_kol != "geometry") {
sf_objekt <- sf_objekt %>%
dplyr::rename(geometry_attr = geometry)
}
# Om geometri-kolumnen inte heter "geometry" → döp om den och uppdatera sf-attribut
if (geom_kol != "geometry") {
sf_objekt <- sf_objekt %>%
dplyr::rename(geometry = !!sym(geom_kol)) %>%
sf::st_set_geometry("geometry")
}
# hantering av legend
legend_position_inside_vals <- NULL
legend_box_margin <- margin(0, 0, 0, 0)
if (tolower(legend_position) %in% c("bottom-right", "bottom-left", "top-right", "top-left", "dala")) {
# Mappa hörn till koordinater
corner_map <- list(
"bottom-right" = c(1, 0),
"bottom-left"  = c(0, 0),
"top-right"    = c(1, 1),
"top-left"     = c(0, 1),
"dala"         = c(0, 0)  # samma som bottom-left
)
legend_position_inside_vals <- corner_map[[tolower(legend_position)]]
legend_position <- "inside"
legend_justification <- legend_position_inside_vals
} else if (is.numeric(legend_position)) {
# Om användaren skickar egna koordinater, t.ex. c(0.8, 0.2)
legend_position_inside_vals <- legend_position
legend_position <- "inside"
legend_justification <- "center"
} else {
# Standard ("right", "bottom", etc.)
legend_position_inside_vals <- NULL
}
if (!is.null(logga_url)) if(logga_url == "dala") logga_url <- "https://raw.githubusercontent.com/Region-Dalarna/depot/main/rd_logo_liggande_fri_svart.png"
# --- Anpassa klasser_antal om för få unika värden finns (för att undvika varning vid klassindelning) ---
antal_unika <- length(unique(na.omit(sf_objekt[[vardekolumn]])))
if (!is.null(klassindelning) && antal_unika < klasser_antal) {
message(glue::glue("ℹ Justerar antal klasser från {klasser_antal} till {antal_unika} (så många unika värden finns)."))
klasser_antal <- antal_unika
}
# --- Klassindelning ---
if (is.null(klassindelning)) {
# Räknar antal unika värden
antal_unika <- length(unique(na.omit(sf_objekt[[vardekolumn]])))
if (klasser_kontinuerlig_skala_oavsett) {
# Använd kontinuerlig färg även om få värden
sf_plot <- sf_objekt %>% mutate(klass = !!sym(vardekolumn))
diskret_skala <- FALSE
} else if (antal_unika < 7) {
# Automatiskt diskret om få värden
sf_plot <- sf_objekt %>% mutate(klass = factor(!!sym(vardekolumn)))
diskret_skala <- TRUE
} else {
# Normal kontinuerlig logik
sf_plot <- sf_objekt %>% mutate(klass = !!sym(vardekolumn))
diskret_skala <- FALSE
}
} else {
diskret_skala <- TRUE  # Klassindelning = diskret skala
if (is.numeric(klassindelning)) {
sf_plot <- sf_objekt %>%
mutate(klass = cut(!!sym(vardekolumn), breaks = klassindelning, include.lowest = TRUE))
} else {
klassindelning <- match.arg(klassindelning, c("kvantil", "pretty", "natural"))
# Automatisk bestämning av decimalprecision (som du redan hade)
bestam_accuracy <- function(values) {
values <- na.omit(values)
if (all(values == round(values))) return(1)
diffs <- diff(sort(unique(values)))
if (min(diffs) >= 1) return(0.1)
if (min(diffs) >= 0.1) return(0.1)
if (min(diffs) >= 0.01) return(0.01)
return(0.001)
}
acc <- bestam_accuracy(sf_objekt[[vardekolumn]])
# Skapa diskreta klasser
if (klassindelning == "kvantil") {
sf_plot <- sf_objekt %>%
mutate(klass = cut(!!sym(vardekolumn),
breaks = quantile(!!sym(vardekolumn), probs = seq(0, 1, length.out = klasser_antal + 1), na.rm = TRUE),
include.lowest = TRUE))
}
if (klassindelning == "pretty") {
sf_plot <- sf_objekt %>%
mutate(klass = cut(!!sym(vardekolumn),
breaks = pretty(range(!!sym(vardekolumn), na.rm = TRUE), n = klasser_antal),
include.lowest = TRUE))
}
if (klassindelning == "natural") {
values <- sf_objekt |> dplyr::pull(!!sym(vardekolumn))
sf_plot <- sf_objekt %>%
mutate(klass = cut(!!sym(vardekolumn),
breaks = suppressWarnings(classInt::classIntervals(values, n = klasser_antal, style = "jenks")$brks),
include.lowest = TRUE))
}
# ✅ Formatera intervall-etiketter (gäller bara faktor)
sf_plot$klass <- forcats::fct_relabel(sf_plot$klass, function(lv) {
sapply(lv, function(x) {
parts <- strsplit(gsub("\\[|\\]|\\(|\\)", "", x), ",")[[1]]
lower <- as.numeric(parts[1]); upper <- as.numeric(parts[2])
if (!is.na(lower) && !is.na(upper) && lower == round(lower) && upper == round(upper)) {
paste0(round(lower), " – ", round(upper))
} else {
paste0(scales::number(lower, accuracy = acc), " – ", scales::number(upper, accuracy = acc))
}
})
})
}
}
# hantera färger - vilket kan bero på antalet klasser
if (is.null(karta_fargvektor)) {
if (exists("diagramfarger")) {
if (length(unique(sf_plot$klass)) < 5) karta_fargvektor <- diagramfarger("rd_karta_gron")
if (length(unique(sf_plot$klass)) < 7) karta_fargvektor <- diagramfarger("rd_karta_gron_sex")
if (length(unique(sf_plot$klass)) == 7) karta_fargvektor <- diagramfarger("rd_karta_gron_sju")
if (length(unique(sf_plot$klass)) > 7) karta_fargvektor <- diagramfarger("rd_karta_gron")
} else {
karta_fargvektor <- "Blues"
}
}
if (!is.na(karta_farg_hogst)) {
# Räkna ut luminans (ljushet) för första och sista färgen i paletten
rgb_start <- grDevices::col2rgb(karta_fargvektor[1])
rgb_slut  <- grDevices::col2rgb(karta_fargvektor[length(karta_fargvektor)])
lum_start <- 0.2126 * rgb_start[1] + 0.7152 * rgb_start[2] + 0.0722 * rgb_start[3]
lum_slut  <- 0.2126 * rgb_slut[1]  + 0.7152 * rgb_slut[2]  + 0.0722 * rgb_slut[3]
# Om första färgen är mörkare än sista → vänd färgvektorn (så ljus låg → mörk hög)
if (lum_start < lum_slut) {
karta_fargvektor <- if (karta_farg_hogst == "mork") rev(karta_fargvektor) else karta_fargvektor
}
}
# --- Grundkarta ---
p <- ggplot(sf_plot) +
geom_sf(aes(fill = klass), color = granser_farg, size = granser_tjocklek) +
{                                       # =========== etiketter om det valts (med ggrepel)
if (!is.null(etiketter_kolumn)) {
ggrepel::geom_text_repel(
aes(label = .data[[etiketter_kolumn]], geometry = geometry),
stat = "sf_coordinates",          # använder sf-objekt för att hämta koordinater
size = etiketter_storlek,
color = etiketter_farg,
family = "sans",
bg.r = 0.15,
bg.color = etiketter_buffer_farg, # färg att ha runt etiketterna
box.padding = 0.3,                # avstånd runt text
point.padding = 0.2,              # avstånd till polygonkant
max.overlaps = Inf,               # visa alla, men sprid ut dem
min.segment.length = 0             # visa linjer om text flyttas
)
}
} +
{                                      # ============ hantering av färger
if (!diskret_skala) {
# Kontinuerlig färgskala
scale_fill_gradientn(colours = karta_fargvektor, name = legend_titel, na.value = na_farg)
} else {
# Diskret färgskala
if (length(karta_fargvektor) > 1) {
scale_fill_manual(values = karta_fargvektor, name = legend_titel, na.value = na_farg)
} else {
scale_fill_brewer(palette = karta_fargvektor, name = legend_titel, na.value = na_farg)
}
}
} +
theme_minimal(base_size = 12) +
labs(
fill    = if (exists("titel_legend")) titel_legend else NULL,
caption = if (exists("karta_caption")) karta_caption else NULL,
title   = if (exists("karta_titel")) karta_titel else NULL
) +
theme(
plot.title.position = "plot",
plot.title = ggtext::element_textbox(
face = "bold",
size = karta_titel_storlek,
width = unit(0.95, "npc"),  # Bredd som proportion av plottens område
halign = 0.5,  # Centrera texten
margin = margin(2, 0, 2, 0)),
legend.position = legend_position,
legend.position.inside = legend_position_inside_vals,
legend.justification = legend_justification,
legend.box.margin = legend_box_margin,
legend.title = element_text(size = legend_titel_storlek),
legend.text  = element_text(size = legend_text_storlek),
legend.key.size = unit(legend_objekt_storlek, "lines"),
plot.caption = element_text(face = "italic",
hjust = 0, vjust = 0, size = karta_caption_storlek),
plot.caption.position = "plot",
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.x  = element_blank(),
axis.text.y  = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(
fill = ifelse(karta_bakgrund == "transparent", NA, karta_bakgrund),
colour = NA),
plot.background = element_rect(
fill = ifelse(karta_bakgrund == "transparent", NA, karta_bakgrund),
colour = NA),
plot.margin = margin(5, 5, 5, 5)
) +
coord_sf(expand = FALSE)
# --- Lägg till logga (om angiven) ---
if (!is.null(logga_url)) {
img <- image_read(logga_url)
logga_ratio <- image_info(img)$height / image_info(img)$width
logga_hojd  <- logga_storlek * logga_ratio
logga_marginal <- 0.01         # till parametrar om det funkar
pos <- list(
#"bottom-right" = list(x = 1 - logga_marginal- logga_storlek, y = -0.5 + logga_marginal + logga_hojd, hjust = 1, vjust = 0),
"bottom-right" = list(x = 1 - logga_marginal, y = -0.5 + logga_marginal + (logga_hojd/2), hjust = 1, vjust = 0),
"bottom-left"  = list(x = 0 + logga_marginal, y = -0.5 + logga_marginal, hjust = 0, vjust = 0),
"top-right"    = list(x = 1 - logga_marginal, y = 0.5 - logga_marginal, hjust = 1, vjust = 1),
"top-left"     = list(x = 0 + logga_marginal, y = 0.5 - logga_marginal, hjust = 0, vjust = 1)
)[[logga_position]]
if (is.null(pos)) {
cat("Ogiltigt värde för 'position'. Tillåtna är: bottom-right, bottom-left, top-right, top-left. Värde sätts till bottom-right")
pos <- list(x = 1 - logga_marginal, y = 0 + logga_marginal, hjust = 1, vjust = 0)
}
p <- cowplot::ggdraw(p) +
cowplot::draw_image(
logga_url,
x = pos$x,
y = pos$y,
#y = -0.45,   # nära nedre högra hörnet
width = logga_storlek,
hjust = pos$hjust,
vjust = pos$vjust
)
}
# --- Skapa mapp ---
if (!is.null(output_mapp)) {
output_mapp <- ifelse(str_ends(output_mapp, "/"), output_mapp, paste0(output_mapp, "/"))
if (!dir.exists(output_mapp)) dir.create(output_mapp, recursive = TRUE)
}
# --- Spara bild ---
if (!is.null(output_mapp) & !is.null(filnamn)) {
# anpassa kartans höjd efter den bredd som angetts i karta_bredd utifrån gis-lagrets form
if (karta_bredd == "auto") {
bbox <- sf::st_bbox(sf_objekt)
aspect_ratio <- (bbox$xmax - bbox$xmin) / (bbox$ymax - bbox$ymin)
karta_bredd <- karta_hojd * aspect_ratio          # Beräkna bredd utifrån karta_hojd
}
fil_sokvag <- paste0(output_mapp, filnamn)
ggsave(fil_sokvag, p, width = karta_bredd, height = karta_hojd, dpi = karta_upplosning,
bg = ifelse(karta_bakgrund == "transparent", NA, karta_bakgrund))
message(glue::glue("✅ Karta skapad: {fil_sokvag}"))
}
if (returnera_ggobj) return(p) else invisible(p)
} # slut funktion för att skriva koropletkarta
skriv_till_diagramfil <- function(ggplot_objekt,
diagramfil_bredd = 12,
diagramfil_hojd = 7,
output_mapp,
filnamn_diagram,
lagg_pa_logga = TRUE,
logga_scaling = 15,
logga_path = NA,
diagram_bildformat = "png"
) {
g <- ggplot_objekt
# Ändra höjd och bredd på den sparade png-filen, + ange mapp och filnamn
bredd <- diagramfil_bredd
hojd <- diagramfil_hojd
if (diagram_bildformat != "png") filnamn_diagram <- filnamn_diagram %>% str_replace(".png", paste0(".", diagram_bildformat))
fullpath <- paste0(output_mapp, filnamn_diagram)
ggsave(fullpath, width = bredd, height = hojd)
# Lägg till logga till diagrammet =======================================
if (lagg_pa_logga){
if (is.na(logga_path)) logga_path <- hamta_logga_path()   # hämta sökväg till diagram
add_logo(
plot_path = paste0(output_mapp, filnamn_diagram), # url or local file for the plot
logo_path = logga_path, # url or local file for the logo
logo_position = "bottom right", # choose a corner
# 'top left', 'top right', 'bottom left' or 'bottom right'
logo_scale = logga_scaling,
#10 as default, but can change to manually make logo bigger (lägre tal = större logga)
replace = TRUE)
}
}
# every_nth <- function(n) {
#   return(function(x) {x[c(TRUE, rep(FALSE, n - 1))]})
# }
every_nth <- function(n, sista_vardet, ta_bort_nast_sista = FALSE) {
return(function(x) {
# Skapar en logisk vektor med var n:te element satt till TRUE
vec <- c(TRUE, rep(FALSE, n - 1))
# Upprepar vektorn så att den täcker hela längden på x
repeated_vec <- rep(vec, length.out = length(x))
# Säkerställer att det sista värdet alltid är TRUE
if (sista_vardet) repeated_vec[length(x)] <- TRUE
# Om ta_bort_nast_sista är TRUE, sätt näst sista elementet till FALSE
if (ta_bort_nast_sista && length(x) > 1) repeated_vec[length(x) - 1] <- FALSE
return(x[repeated_vec])
})
}
source("https://raw.githubusercontent.com/Region-Dalarna/funktioner/main/func_API.R", encoding = "utf-8", echo = FALSE)
github_commit_push(repo = "funktioner", commit_txt = "Buggfix stödlinjer-funktionen som nu funkar även när skalan går över nollinjen.")
source("G:/skript/hamta_data/func_gymnasieantagningen.R")
shiny_mapp <- "G:/skript/peter/shiny/gymnasiet/data/"
inlas_df <- las_in_data_gymnasieantagningen()
gymnant_df <- inlas_df %>%
group_by(ar, Organisationstyp, Kommunkod = KommKod, Kommun, pr_kod, program,
pr_inr_kod = Anskod, program_inriktning = Program_inriktning) %>%
summarise(platser = sum(Org, na.rm = TRUE),
antagna_killar = sum(Ant_Män, na.rm = TRUE),
antagna_tjejer = sum(Ant_Kv, na.rm = TRUE),
forstasok_killar = sum(`1a_Män`, na.rm = TRUE),
forstasok_tjejer = sum(`1a_Kv`, na.rm = TRUE),
.groups = "drop") %>%
mutate(program_inriktning = if_else(is.na(program_inriktning), program, program_inriktning)) %>%
pivot_longer(
cols = c(antagna_killar, antagna_tjejer, forstasok_killar, forstasok_tjejer, platser),
names_to = c("variabel", "kon"),
names_sep = "_",
values_to = "antal"
) %>%
mutate(kon = ifelse(is.na(kon), "båda", kon))
saveRDS(gymnant_df, paste0(shiny_mapp, "gymnant_df.rds"))
gymnant_df <- inlas_df %>%
group_by(ar, Organisationstyp, Kommunkod = KommKod, Kommun, pr_kod, program,
pr_inr_kod = Anskod, program_inriktning = Program_inriktning) %>%
summarise(platser = sum(Org, na.rm = TRUE),
antagna_killar = sum(Ant_Män, na.rm = TRUE),
antagna_tjejer = sum(Ant_Kv, na.rm = TRUE),
forstasok_killar = sum(`1a_Män`, na.rm = TRUE),
forstasok_tjejer = sum(`1a_Kv`, na.rm = TRUE),
.groups = "drop") %>%
mutate(program_inriktning = if_else(is.na(program_inriktning), program, program_inriktning)) %>%
pivot_longer(
cols = c(antagna_killar, antagna_tjejer, forstasok_killar, forstasok_tjejer, platser),
names_to = c("variabel", "kon"),
names_sep = "_",
values_to = "antal"
) %>%
mutate(kon = ifelse(is.na(kon), "båda", kon),
ar = ar %>% as.numeric())
saveRDS(gymnant_df, paste0(shiny_mapp, "gymnant_df.rds"))
